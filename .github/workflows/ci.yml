name: CI/CD Pipeline

on:
  push:
    branches: [ main, develop, dev, staging ]
  pull_request:
    branches: [ main, develop, dev ]
  workflow_dispatch:
    inputs:
      environment:
        description: 'Target environment'
        required: true
        default: 'staging'
        type: choice
        options:
        - development
        - staging
        - production
      deploy_railway:
        description: 'Deploy to Railway'
        required: false
        default: false
        type: boolean
      deploy_gcp:
        description: 'Deploy to GCP'
        required: false
        default: false
        type: boolean

env:
  NODE_VERSION: '18'
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  # Environment Validation
  validate-environment:
    name: üîç Validate Environment
    runs-on: ubuntu-latest
    outputs:
      environment: ${{ steps.env.outputs.environment }}
      should_deploy: ${{ steps.env.outputs.should_deploy }}
    
    steps:
    - name: üì• Checkout code
      uses: actions/checkout@v4
      
    - name: üîß Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: ${{ env.NODE_VERSION }}
        cache: 'npm'
        
    - name: üì¶ Install dependencies
      run: npm ci
      
    - name: üîç Determine environment
      id: env
      run: |
        if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
          ENVIRONMENT="${{ github.event.inputs.environment }}"
        elif [[ "${{ github.ref }}" == "refs/heads/main" ]]; then
          ENVIRONMENT="production"
        elif [[ "${{ github.ref }}" == "refs/heads/staging" ]]; then
          ENVIRONMENT="staging"
        else
          ENVIRONMENT="development"
        fi
        
        SHOULD_DEPLOY="false"
        if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
          if [[ "${{ github.event.inputs.deploy_railway }}" == "true" || "${{ github.event.inputs.deploy_gcp }}" == "true" ]]; then
            SHOULD_DEPLOY="true"
          fi
        elif [[ "${{ github.ref }}" == "refs/heads/main" || "${{ github.ref }}" == "refs/heads/staging" ]]; then
          SHOULD_DEPLOY="true"
        fi
        
        echo "environment=$ENVIRONMENT" >> $GITHUB_OUTPUT
        echo "should_deploy=$SHOULD_DEPLOY" >> $GITHUB_OUTPUT
        echo "üåç Environment: $ENVIRONMENT"
        echo "üöÄ Should Deploy: $SHOULD_DEPLOY"
        
    - name: üîê Validate environment schema
      run: |
        if [[ -f ".env.schema.json" ]]; then
          echo "‚úÖ Environment schema found"
          # Validate schema format
          if ! jq empty .env.schema.json; then
            echo "‚ùå Invalid JSON in .env.schema.json"
            exit 1
          fi
          echo "‚úÖ Environment schema valid"
        else
          echo "‚ö†Ô∏è No .env.schema.json found"
        fi
        
    - name: üîß Setup test environment
      run: |
        # Create test environment file
        cat > .env.test << EOF
        NODE_ENV=test
        PORT=8080
        DATABASE_URL=postgresql://test:test@localhost:5432/test
        REDIS_URL=redis://localhost:6379
        JWT_SECRET=test-secret-for-ci-only
        STRIPE_SECRET_KEY=sk_test_dummy
        PINECONE_API_KEY=test-dummy-key
        EOF
        
        echo "‚úÖ Test environment configured"

  # Security & Quality Checks
  security-quality:
    name: üîí Security & Quality
    runs-on: ubuntu-latest
    needs: validate-environment
    
    steps:
    - name: üì• Checkout code
      uses: actions/checkout@v4
      
    - name: üîß Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: ${{ env.NODE_VERSION }}
        cache: 'npm'
        
    - name: üì¶ Install dependencies
      run: npm ci
      
    - name: üîç Run secrets validation
      run: |
        # Make scripts executable
        chmod +x tools/validate-secrets.sh
        chmod +x tools/setup-env.sh
        
        # Test validation script
        if [[ -f "tools/validate-secrets.sh" ]]; then
          echo "üîç Running secrets validation..."
          ./tools/validate-secrets.sh || echo "‚ö†Ô∏è Validation script completed with warnings"
        else
          echo "‚ö†Ô∏è Secrets validation script not found"
        fi
        
    - name: üîç Security audit
      run: |
        echo "üîç Running npm audit..."
        npm audit --audit-level=moderate
        
        echo "üîç Checking for secrets in code..."
        # Check for potential secrets
        if grep -r -i "sk_test\|sk_live\|password\|secret\|key" --include="*.js" --include="*.ts" --include="*.json" --exclude-dir=node_modules --exclude-dir=.git . | head -10; then
          echo "‚ö†Ô∏è Potential secrets found in code - review needed"
        else
          echo "‚úÖ No obvious secrets found in code"
        fi
        
    - name: üìä Code quality checks
      run: |
        echo "üìä Running code quality checks..."
        
        # Check package.json
        if ! jq empty package.json; then
          echo "‚ùå Invalid package.json"
          exit 1
        fi
        echo "‚úÖ package.json valid"
        
        # Check for required scripts
        REQUIRED_SCRIPTS=("start" "test")
        for script in "${REQUIRED_SCRIPTS[@]}"; do
          if jq -e ".scripts.\"$script\"" package.json > /dev/null; then
            echo "‚úÖ Script '$script' found"
          else
            echo "‚ö†Ô∏è Script '$script' not found"
          fi
        done
        
    - name: üîç Lint and format
      run: |
        echo "üîç Running linting..."
        if npm run lint --if-present; then
          echo "‚úÖ Linting passed"
        else
          echo "‚ö†Ô∏è Linting not configured or failed"
        fi
        
        echo "üîç Running type checking..."
        if npm run type-check --if-present; then
          echo "‚úÖ Type checking passed"
        else
          echo "‚ö†Ô∏è Type checking not configured or failed"
        fi

  # Unit Tests
  unit-tests:
    name: üß™ Unit Tests
    runs-on: ubuntu-latest
    needs: validate-environment
    
    services:
      postgres:
        image: postgres:14
        env:
          POSTGRES_PASSWORD: test
          POSTGRES_USER: test
          POSTGRES_DB: test
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 5432:5432
          
      redis:
        image: redis:7
        options: >-
          --health-cmd "redis-cli ping"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 6379:6379
    
    steps:
    - name: üì• Checkout code
      uses: actions/checkout@v4
      
    - name: üîß Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: ${{ env.NODE_VERSION }}
        cache: 'npm'
        
    - name: üì¶ Install dependencies
      run: npm ci
      
    - name: üê≥ Setup test databases
      run: |
        echo "üê≥ Setting up test databases..."
        
        # Wait for databases to be ready
        timeout 60 bash -c 'until pg_isready -h localhost -p 5432; do sleep 1; done'
        timeout 60 bash -c 'until redis-cli -h localhost -p 6379 ping; do sleep 1; done'
        
        echo "‚úÖ Databases ready"
        
    - name: üß™ Run unit tests
      run: |
        echo "üß™ Running unit tests..."
        
        # Create test environment
        cat > .env.test << EOF
        NODE_ENV=test
        DATABASE_URL=postgresql://test:test@localhost:5432/test
        REDIS_URL=redis://localhost:6379
        JWT_SECRET=test-secret-for-ci
        EOF
        
        # Run tests
        if npm run test --if-present; then
          echo "‚úÖ Unit tests passed"
        else
          echo "‚ùå Unit tests failed"
          exit 1
        fi
        
    - name: üìä Test coverage
      run: |
        echo "üìä Running test coverage..."
        if npm run test:coverage --if-present; then
          echo "‚úÖ Coverage report generated"
        else
          echo "‚ö†Ô∏è Coverage not configured"
        fi
        
    - name: üìã Upload coverage reports
      uses: codecov/codecov-action@v3
      if: success()
      with:
        file: ./coverage/lcov.info
        flags: unittests
        name: codecov-umbrella

  # Service-Specific Tests
  service-tests:
    name: üîß Service Tests
    runs-on: ubuntu-latest
    needs: validate-environment
    
    services:
      postgres:
        image: postgres:14
        env:
          POSTGRES_PASSWORD: test
          POSTGRES_USER: test
          POSTGRES_DB: test
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 5432:5432
          
      redis:
        image: redis:7
        options: >-
          --health-cmd "redis-cli ping"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 6379:6379
          
      mongodb:
        image: mongo:6
        options: >-
          --health-cmd "echo 'db.runCommand(\"ping\").ok' | mongo localhost:27017/test --quiet"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 27017:27017
    
    steps:
    - name: üì• Checkout code
      uses: actions/checkout@v4
      
    - name: üîß Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: ${{ env.NODE_VERSION }}
        cache: 'npm'
        
    - name: üì¶ Install dependencies
      run: npm ci
      
    - name: üîß Install test tools
      run: |
        sudo apt-get update
        sudo apt-get install -y postgresql-client redis-tools
        
    - name: üß™ Run service-specific tests
      run: |
        echo "üß™ Running service-specific tests..."
        
        # Make scripts executable
        chmod +x tools/service-specific-tests.sh
        
        # Create test environment
        cat > .env << EOF
        NODE_ENV=test
        DATABASE_URL=postgresql://test:test@localhost:5432/test
        REDIS_URL=redis://localhost:6379
        MONGODB_URI=mongodb://localhost:27017/test
        JWT_SECRET=test-secret-for-ci
        EOF
        
        # Run service tests
        if [[ -f "tools/service-specific-tests.sh" ]]; then
          echo "üîç Running PostgreSQL tests..."
          ./tools/service-specific-tests.sh postgresql test || echo "‚ö†Ô∏è PostgreSQL tests completed with warnings"
          
          echo "üîç Running Redis tests..."
          ./tools/service-specific-tests.sh redis test || echo "‚ö†Ô∏è Redis tests completed with warnings"
          
          echo "üîç Running MongoDB tests..."
          ./tools/service-specific-tests.sh mongodb test || echo "‚ö†Ô∏è MongoDB tests completed with warnings"
          
          echo "üîç Running API tests..."
          ./tools/service-specific-tests.sh api test || echo "‚ö†Ô∏è API tests completed with warnings"
          
          echo "‚úÖ Service tests completed"
        else
          echo "‚ö†Ô∏è Service test script not found"
        fi

  # Build and Docker Tests
  build-test:
    name: üèóÔ∏è Build & Docker
    runs-on: ubuntu-latest
    needs: [validate-environment, security-quality, unit-tests]
    
    steps:
    - name: üì• Checkout code
      uses: actions/checkout@v4
      
    - name: üîß Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: ${{ env.NODE_VERSION }}
        cache: 'npm'
        
    - name: üì¶ Install dependencies
      run: npm ci
      
    - name: üèóÔ∏è Build application
      run: |
        echo "üèóÔ∏è Building application..."
        if npm run build --if-present; then
          echo "‚úÖ Build successful"
        else
          echo "‚ö†Ô∏è Build not configured or failed"
        fi
        
    - name: üê≥ Set up Docker Buildx
      uses: docker/setup-buildx-action@v3
      
    - name: üê≥ Test Docker build
      run: |
        echo "üê≥ Testing Docker build..."
        
        # Test if Dockerfile exists
        if [[ -f "Dockerfile" ]]; then
          echo "‚úÖ Dockerfile found"
          
          # Test build
          if docker build -t test-build .; then
            echo "‚úÖ Docker build successful"
            
            # Test image size
            IMAGE_SIZE=$(docker images test-build --format "{{.Size}}")
            echo "üìä Image size: $IMAGE_SIZE"
            
            # Clean up
            docker rmi test-build
          else
            echo "‚ùå Docker build failed"
            exit 1
          fi
        else
          echo "‚ö†Ô∏è No Dockerfile found"
        fi
        
    - name: üìä Build analysis
      run: |
        echo "üìä Analyzing build artifacts..."
        
        # Check for build artifacts
        if [[ -d "dist" ]]; then
          DIST_SIZE=$(du -sh dist | cut -f1)
          echo "üìä Dist size: $DIST_SIZE"
        fi
        
        if [[ -d "build" ]]; then
          BUILD_SIZE=$(du -sh build | cut -f1)
          echo "üìä Build size: $BUILD_SIZE"
        fi

  # Deployment Tests
  deployment-test:
    name: üöÄ Deployment Test
    runs-on: ubuntu-latest
    needs: [validate-environment, build-test]
    if: needs.validate-environment.outputs.should_deploy == 'true'
    
    steps:
    - name: üì• Checkout code
      uses: actions/checkout@v4
      
    - name: üîß Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: ${{ env.NODE_VERSION }}
        cache: 'npm'
        
    - name: üì¶ Install dependencies
      run: npm ci
      
    - name: üß™ Run deployment tests
      run: |
        echo "üß™ Running deployment tests..."
        
        # Make scripts executable
        chmod +x infra/test-deployment.sh
        
        # Create test environment
        cat > .env << EOF
        NODE_ENV=test
        DATABASE_URL=postgresql://test:test@localhost:5432/test
        REDIS_URL=redis://localhost:6379
        JWT_SECRET=test-secret-for-ci
        EOF
        
        # Run deployment tests
        if [[ -f "infra/test-deployment.sh" ]]; then
          echo "üîç Running comprehensive deployment test..."
          ./infra/test-deployment.sh comprehensive test || echo "‚ö†Ô∏è Deployment tests completed with warnings"
          echo "‚úÖ Deployment tests completed"
        else
          echo "‚ö†Ô∏è Deployment test script not found"
        fi

  # Railway Deployment
  deploy-railway:
    name: üöÇ Deploy to Railway
    runs-on: ubuntu-latest
    needs: [validate-environment, security-quality, unit-tests, deployment-test]
    if: |
      needs.validate-environment.outputs.should_deploy == 'true' && 
      (github.event_name == 'workflow_dispatch' && github.event.inputs.deploy_railway == 'true' ||
       github.ref == 'refs/heads/main' || github.ref == 'refs/heads/staging')
    environment:
      name: ${{ needs.validate-environment.outputs.environment }}
      url: ${{ steps.deploy.outputs.url }}
    
    steps:
    - name: üì• Checkout code
      uses: actions/checkout@v4
      
    - name: üîß Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: ${{ env.NODE_VERSION }}
        cache: 'npm'
        
    - name: üì¶ Install dependencies
      run: npm ci
      
    - name: üöÇ Setup Railway CLI
      run: npm install -g @railway/cli
      
    - name: üîê Login to Railway
      run: railway login --token ${{ secrets.RAILWAY_TOKEN }}
      
    - name: üöÇ Deploy to Railway
      id: deploy
      run: |
        echo "üöÇ Deploying to Railway..."
        
        # Link project if needed
        if ! railway status; then
          echo "üîó Linking Railway project..."
          railway link
        fi
        
        # Deploy
        railway up
        
        # Get service URLs
        SERVICE_URLS=$(railway status --json | jq -r '.[].url' | head -1)
        echo "url=$SERVICE_URLS" >> $GITHUB_OUTPUT
        
        echo "‚úÖ Railway deployment completed"
        echo "üåê Service URL: $SERVICE_URLS"
        
    - name: üß™ Test Railway deployment
      run: |
        echo "üß™ Testing Railway deployment..."
        
        # Wait for deployment to be ready
        sleep 30
        
        # Test health endpoint
        if curl -f ${{ steps.deploy.outputs.url }}/health; then
          echo "‚úÖ Railway health check passed"
        else
          echo "‚ö†Ô∏è Railway health check failed"
        fi

  # GCP Deployment
  deploy-gcp:
    name: ‚òÅÔ∏è Deploy to GCP
    runs-on: ubuntu-latest
    needs: [validate-environment, security-quality, unit-tests, deployment-test]
    if: |
      needs.validate-environment.outputs.should_deploy == 'true' && 
      (github.event_name == 'workflow_dispatch' && github.event.inputs.deploy_gcp == 'true' ||
       github.ref == 'refs/heads/main' || github.ref == 'refs/heads/staging')
    environment:
      name: ${{ needs.validate-environment.outputs.environment }}
      url: ${{ steps.deploy.outputs.url }}
    
    permissions:
      contents: 'read'
      id-token: 'write'
      
    steps:
    - name: üì• Checkout code
      uses: actions/checkout@v4
      
    - name: üîê Authenticate to GCP
      uses: google-github-actions/auth@v1
      with:
        credentials_json: ${{ secrets.GCP_SA_KEY }}
        
    - name: ‚òÅÔ∏è Setup GCP CLI
      uses: google-github-actions/setup-gcloud@v1
      with:
        project_id: ${{ secrets.GCP_PROJECT_ID }}
        
    - name: üê≥ Setup Docker Buildx
      uses: docker/setup-buildx-action@v3
      
    - name: üîê Login to Artifact Registry
      uses: docker/login-action@v3
      with:
        registry: ${{ secrets.GCP_REGION }}-docker.pkg.dev
        username: _json_key
        password: ${{ secrets.GCP_SA_KEY }}
        
    - name: üèóÔ∏è Build and push Docker image
      run: |
        echo "üèóÔ∏è Building Docker image..."
        
        IMAGE_PATH="${{ secrets.GCP_REGION }}-docker.pkg.dev/${{ secrets.GCP_PROJECT_ID }}/${{ secrets.GCP_REPOSITORY }}/app:${{ github.sha }}"
        
        # Build and push
        docker build -t "$IMAGE_PATH" .
        docker push "$IMAGE_PATH"
        
        echo "‚úÖ Docker image pushed: $IMAGE_PATH"
        echo "image_path=$IMAGE_PATH" >> $GITHUB_ENV
        
    - name: ‚òÅÔ∏è Deploy to Cloud Run
      id: deploy
      run: |
        echo "‚òÅÔ∏è Deploying to Cloud Run..."
        
        SERVICE_NAME="${{ github.ref_name }}-${{ github.sha }}"
        
        # Deploy to Cloud Run
        gcloud run deploy "$SERVICE_NAME" \
          --image="$IMAGE_PATH" \
          --region="${{ secrets.GCP_REGION }}" \
          --platform=managed \
          --allow-unauthenticated \
          --set-env-vars="NODE_ENV=${{ needs.validate-environment.outputs.environment }}" \
          --quiet
          
        # Get service URL
        SERVICE_URL=$(gcloud run services describe "$SERVICE_NAME" \
          --region="${{ secrets.GCP_REGION }}" \
          --format="value(status.url)")
          
        echo "url=$SERVICE_URL" >> $GITHUB_OUTPUT
        echo "service_name=$SERVICE_NAME" >> $GITHUB_OUTPUT
        
        echo "‚úÖ GCP deployment completed"
        echo "üåê Service URL: $SERVICE_URL"
        
    - name: üß™ Test GCP deployment
      run: |
        echo "üß™ Testing GCP deployment..."
        
        # Wait for deployment to be ready
        sleep 30
        
        # Test health endpoint
        if curl -f ${{ steps.deploy.outputs.url }}/health; then
          echo "‚úÖ GCP health check passed"
        else
          echo "‚ö†Ô∏è GCP health check failed"
        fi

  # Health Check & Monitoring
  health-check:
    name: üè• Health Check
    runs-on: ubuntu-latest
    needs: [validate-environment, deploy-railway, deploy-gcp]
    if: always() && (needs.deploy-railway.result == 'success' || needs.deploy-gcp.result == 'success')
    
    steps:
    - name: üì• Checkout code
      uses: actions/checkout@v4
      
    - name: üîß Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: ${{ env.NODE_VERSION }}
        cache: 'npm'
        
    - name: üì¶ Install dependencies
      run: npm ci
      
    - name: üè• Run health checks
      run: |
        echo "üè• Running post-deployment health checks..."
        
        # Make scripts executable
        chmod +x tools/health-check.sh
        
        # Create test environment
        cat > .env << EOF
        NODE_ENV=${{ needs.validate-environment.outputs.environment }}
        DATABASE_URL=postgresql://test:test@localhost:5432/test
        REDIS_URL=redis://localhost:6379
        JWT_SECRET=test-secret-for-ci
        EOF
        
        # Run health check
        if [[ -f "tools/health-check.sh" ]]; then
          echo "üîç Running comprehensive health check..."
          ./tools/health-check.sh ${{ needs.validate-environment.outputs.environment }} local || echo "‚ö†Ô∏è Health check completed with warnings"
          echo "‚úÖ Health check completed"
        else
          echo "‚ö†Ô∏è Health check script not found"
        fi

  # Notification
  notify:
    name: üì¢ Notify Results
    runs-on: ubuntu-latest
    needs: [validate-environment, security-quality, unit-tests, service-tests, build-test, deployment-test, deploy-railway, deploy-gcp, health-check]
    if: always()
    
    steps:
    - name: üì¢ Build notification message
      id: message
      run: |
        ENVIRONMENT="${{ needs.validate-environment.outputs.environment }}"
        
        MESSAGE="## üöÄ Deployment Results
        
        **Environment:** $ENVIRONMENT
        **Branch:** ${{ github.ref_name }}
        **Commit:** ${{ github.sha }}
        
        ### üìä Job Results:
        
        - üîç **Environment Validation:** ${{ needs.validate-environment.result }}
        - üîí **Security & Quality:** ${{ needs.security-quality.result }}
        - üß™ **Unit Tests:** ${{ needs.unit-tests.result }}
        - üîß **Service Tests:** ${{ needs.service-tests.result }}
        - üèóÔ∏è **Build & Docker:** ${{ needs.build-test.result }}
        - üöÄ **Deployment Test:** ${{ needs.deployment-test.result }}"
        
        if [[ "${{ needs.deploy-railway.result }}" != "skipped" ]]; then
          MESSAGE="$MESSAGE
        - üöÇ **Railway Deployment:** ${{ needs.deploy-railway.result }}"
        fi
        
        if [[ "${{ needs.deploy-gcp.result }}" != "skipped" ]]; then
          MESSAGE="$MESSAGE
        - ‚òÅÔ∏è **GCP Deployment:** ${{ needs.deploy-gcp.result }}"
        fi
        
        MESSAGE="$MESSAGE
        - üè• **Health Check:** ${{ needs.health-check.result }}"
        
        ### üéØ Overall Status: "
        
        # Determine overall status
        if [[ "${{ needs.unit-tests.result }}" == "failure" || "${{ needs.security-quality.result }}" == "failure" ]]; then
          MESSAGE="$MESSAGE‚ùå FAILED"
        elif [[ "${{ needs.deploy-railway.result }}" == "failure" || "${{ needs.deploy-gcp.result }}" == "failure" ]]; then
          MESSAGE="$MESSAGE‚ö†Ô∏è PARTIAL FAILURE"
        else
          MESSAGE="$MESSAGE‚úÖ SUCCESS"
        fi
        
        echo "message<<EOF" >> $GITHUB_OUTPUT
        echo "$MESSAGE" >> $GITHUB_OUTPUT
        echo "EOF" >> $GITHUB_OUTPUT
        
    - name: üì¢ Post to Slack (if configured)
      if: env.SLACK_WEBHOOK_URL != ''
      env:
        SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
      run: |
        curl -X POST -H 'Content-type: application/json' \
          --data '{"text":"${{ steps.message.outputs.message }}"}' \
          "$SLACK_WEBHOOK_URL"
          
    - name: üì¢ Comment on PR
      if: github.event_name == 'pull_request'
      uses: actions/github-script@v6
      with:
        script: |
          github.rest.issues.createComment({
            issue_number: context.issue.number,
            owner: context.repo.owner,
            repo: context.repo.repo,
            body: `${{ steps.message.outputs.message }}`
          })

  # Cleanup
  cleanup:
    name: üßπ Cleanup
    runs-on: ubuntu-latest
    needs: [deploy-gcp]
    if: always() && needs.deploy-gcp.result == 'success'
    
    steps:
    - name: üîê Authenticate to GCP
      uses: google-github-actions/auth@v1
      with:
        credentials_json: ${{ secrets.GCP_SA_KEY }}
        
    - name: ‚òÅÔ∏è Setup GCP CLI
      uses: google-github-actions/setup-gcloud@v1
      with:
        project_id: ${{ secrets.GCP_PROJECT_ID }}
        
    - name: üßπ Cleanup old deployments
      run: |
        echo "üßπ Cleaning up old Cloud Run deployments..."
        
        # Keep only last 5 deployments
        gcloud run services list \
          --region="${{ secrets.GCP_REGION }}" \
          --format="value(name)" \
          | grep "${{ github.ref_name }}" \
          | sort -r \
          | tail -n +6 \
          | xargs -r -I {} gcloud run services delete {} \
            --region="${{ secrets.GCP_REGION }}" \
            --quiet
            
        echo "‚úÖ Cleanup completed"
